import{_ as e,c as t,o as a,a as s}from"./app.0e0fc182.js";const f=JSON.parse('{"title":"Shadowsocks","description":"","frontmatter":{},"headers":[{"level":2,"title":"Shadowsocks","slug":"shadowsocks"},{"level":3,"title":"Addressing","slug":"addressing"},{"level":3,"title":"TCP","slug":"tcp"},{"level":3,"title":"UDP","slug":"udp"}],"relativePath":"guide/what-is-shadowsocks.md","lastUpdated":1656395509000}'),r={name:"guide/what-is-shadowsocks.md"},o=s(`<h2 id="shadowsocks" tabindex="-1">Shadowsocks <a class="header-anchor" href="#shadowsocks" aria-hidden="true">#</a></h2><p>Shadowsocks is a secure split proxy loosely based on <a href="https://tools.ietf.org/html/rfc1928" target="_blank" rel="noopener noreferrer">SOCKS5</a>.</p><pre><code>client &lt;---&gt; ss-local &lt;--[encrypted]--&gt; ss-remote &lt;---&gt; target
</code></pre><p>The Shadowsocks local component (ss-local) acts like a traditional SOCKS5 server and provides proxy service to clients. It encrypts and forwards data streams and packets from the client to the Shadowsocks remote component (ss-remote), which decrypts and forwards to the target. Replies from target are similarly encrypted and relayed by ss-remote back to ss-local, which decrypts and eventually returns to the original client.</p><h3 id="addressing" tabindex="-1">Addressing <a class="header-anchor" href="#addressing" aria-hidden="true">#</a></h3><p>Addresses used in Shadowsocks follow the <a href="https://tools.ietf.org/html/rfc1928#section-5" target="_blank" rel="noopener noreferrer">SOCKS5 address format</a>:</p><pre><code>[1-byte type][variable-length host][2-byte port]
</code></pre><p>The following address types are defined:</p><ul><li><code>0x01</code>: host is a 4-byte IPv4 address.</li><li><code>0x03</code>: host is a variable length string, starting with a 1-byte length, followed by up to 255-byte domain name.</li><li><code>0x04</code>: host is a 16-byte IPv6 address.</li></ul><p>The port number is a 2-byte big-endian unsigned integer.</p><h3 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-hidden="true">#</a></h3><p>ss-local initiates a TCP connection to ss-remote by sending an encrypted data stream starting with the target address followed by payload data. The exact encryption scheme differs depending on the cipher used.</p><pre><code>[target address][payload]
</code></pre><p>ss-remote receives the encrypted data stream, decrypts and parses the leading target address. It then establishes a new TCP connection to the target and forwards payload data to it. ss-remote receives reply from the target, encrypts and forwards it back to the ss-local, until ss-local disconnects.</p><p>For better obfuscation purposes, both local and remote SHOULD send the handshake data along with some payload in the first packet.</p><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-hidden="true">#</a></h3><p>ss-local sends an encrypted data packet containing the target address and payload to ss-remote.</p><pre><code>[target address][payload]
</code></pre><p>Upon receiving the encrypted packet, ss-remote decrypts and parses the target address. It then sends a new data packet containing only the payload to the target. ss-remote receives data packets back from target and prepends the target address to the payload in each packet, then sends encrypted copies back to ss-local.</p><pre><code>[target address][payload]
</code></pre><p>Essentially, ss-remote is performing Network Address Translation for ss-local.</p>`,21),d=[o];function n(c,i,l,p,h,g){return a(),t("div",null,d)}var m=e(r,[["render",n]]);export{f as __pageData,m as default};
